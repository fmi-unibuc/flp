\documentclass[xcolor=pdftex,romanian,colorlinks]{beamer}

\usepackage{../tslides}
\usepackage{comment}

\title[SLP---Tipologie]{Semantica limbajelor de programare}
\subtitle{Tipuri de Semantică}
\begin{document}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Feluri de a da semantica}
\begin{itemize}
  \item Limbaj de programare: sintaxă și semantică
  \vitem Feluri de semantică
  \begin{itemize}
  \item Limbaj natural --- descriere textuală a efectelor
  \vitem Operațională --- asocierea unei demonstrații a execuției
  \vitem Axiomatică --- Descrierea folosind logică a efectelor unei instrucțiuni
  \vitem Denotațională --- prin asocierea unui obiect matematic (denotație)

  \vitem Statică --- Asocierea unui sistem de tipuri care exclude programe eronate
  \end{itemize}
\end{itemize}
\end{frame}

\begin{subsection}{IMP}
\begin{frame}[fragile]{IMP: un limbaj \structure{IMP}erativ foarte simplu}\ 
\begin{block}{Ce conține}
\begin{minipage}{.49\columnwidth}
\begin{itemize}
\vitem Expresii
\begin{itemize}
  \item Aritmetice %\hfill $x + 3$
  \item Booleene %\hfill $\Snot(x > 7)$
\end{itemize}
\vitem Blocuri de instrucțiuni
\begin{itemize}
  \item De atribuire %\hfill $x = 5;$
  \item Condiționale %\hfill $\Sif(x > 7)\; \{x =5; \} \Selse \{x = 0;\}$
  \item De ciclare   %\hfill$\Swhile (x > 7)\; \{x = x - 1;\}$
  \item De interacțiune I/O
\end{itemize}
\end{itemize}
\end{minipage}
\begin{minipage}{.49\columnwidth}
\begin{asciic}
  var n = 0; read("n=", n);
  var prime = true;
  var i = 1;
  while (prime && i * i < n) {
      i = i + 1;
      if (n % i == 0) prime = false
      else {}
  };
  if (prime) print("Is prime: ", n)
  else print("Is not prime: ", n)  
\end{asciic}
\end{minipage}
\end{block}
\begin{block}{Ce nu conține}
\begin{itemize}
\item Proceduri și funcții
\item Schimbări abrupte de control
\end{itemize}
\end{block}
\end{frame}

\begin{comment}
 \begin{frame}{Sintaxă formală}{Backus Naur Form}
  \begin{itemize}
   \item Pentru gramatici (generative) independente de context
   \item Producții
       --- generează termeni prin expandare (rescriere)

\alert{\renewcommand{\syntaxKeyword}{}\syntax[\Stmt]{\color{black}\Sif\;\terminal{(}\BExp\terminal{)}\Block\Selse\Block}{}
	\syntaxCont[\Stmt]{\color{black}\Id \terminal{=}\AExp\terminal{;}}{}}
   \item Categorii sintactice (neterminale, încep cu majusculă)
   \begin{itemize}
    \item descriu tipurile de sintaxă
     \begin{itemize}
      \item Tipuri lexicale: %$\Int$ (întregi), $\Id$ (identificatori), $\Bool$ (Booleeni)
	  \item Tipuri construite:
     %$\AExp$ (expr. aritmetice), $\BExp$ (expr. Booleene), \\$\Stmt$ (instrucțiuni), $\Block$ (bloc de instrucțiuni), $\Pgm$ (program)
     \end{itemize}
   \end{itemize}
   \item Cuvinte cheie (terminale, încep cu literă mică sau simboluri)
   \begin{itemize}
    \item descriu elementele lexicale:
   $\Sif$, $\Selse$, $\Sint$,
   $\Swhile$,
   $\terminal{<=}$,
   $\terminal{\&\&}$, $\terminal{!}$,
   $\terminal{+}$, $\terminal{=}$, $\terminal{;}$, $\terminal{(}$, $\terminal{)}$, \ldots
   \end{itemize}
  \end{itemize}
 \end{frame}
\end{comment}

\begin{frame}{Sintaxă formală}{Sintaxa BNF a limbajului IMP}
\vspace{-5ex}\begin{syntaxBlock}{\AExp}
\alert{
\begin{itemize}
\item[]\renewcommand{\syntaxKeyword}{}
\syntax{\Int\Smid\Id \Smid \Bool}{}
\syntaxCont{\AExp\terminal{+}\AExp\Smid\AExp\terminal{*}\AExp\Smid\AExp\terminal{/}\AExp}{}
\syntaxCont{\AExp\terminal{<=}\AExp \Smid \AExp\terminal{==}\AExp}{}
\syntaxCont{\Snot\AExp \Smid \AExp \terminal{\&\&} \AExp}{}
\item[]\renewcommand{\defSort}{\Block}
\syntax{\terminal{var} \Id\terminal{=}\AExp \Smid \Id\terminal{=}\AExp}{}
\syntaxCont{\Sif\;\terminal{(}\BExp\terminal{)}\Block\Selse\Block}{}
\syntaxCont{\Swhile\;\terminal{(}\BExp\terminal{)}\Block}{}
\syntaxCont{\Sget\;\terminal{(}\String\terminal{,} \Id\terminal{)} \Smid
\Sput\;\terminal{(}\String\terminal{,} \AExp\terminal{)}}{}
\syntaxCont{\terminal{\{} \{\Stmt \terminal{;}\}\ast\terminal{\}}}{}
\item[]\renewcommand{\defSort}{\Pgm}
\syntax{ \{\Stmt \terminal{;}\}\ast }{}
\end{itemize}
}
\end{syntaxBlock}
unde $\Int$ reprezintă numere întregi, $\Bool$ constante de adevăr, $\Id$ identificatori,
și $\String$ șiruri de caractere.
\end{frame}
\end{subsection}

\begin{section}{Semantică statică}
  \begin{frame}{Semantică Statică - Motivație}
    \begin{itemize}
      \item Este sintaxa unui limbaj de programare prea expresivă?
      \item Sunt programe care n-aș vrea să le pot scrie, dar le pot?
      \begin{itemize}
        \item<2-> Pot aduna întregi cu Booleeni
        \item<2-> \lstinline{2 <= 3 <= 5}
      \end{itemize}
    \vitem Putem detecta programe greșite înainte de rulare?
    \item Putem garanta că execuția programului nu se va bloca?

    \begin{itemize}
      \item<2-> folosirea variabilelor fără a le declara
      \item<2-> tipuri incompatibile (variabile, dar și expresii)
    \end{itemize}
    \vitem<3> Soluție: Sistemele de tipuri
    \end{itemize}
    \end{frame}

    \begin{frame}{Sisteme de tipuri}{La ce folosesc?}

    \begin{itemize}
    \item Descriu programele „bine formate“
    \item Pot preveni anumite erori
    \begin{itemize}
    \item folosirea variabilelor nedeclarate/neințializate
    \item detectarea unor bucați de cod inaccesibile
    \item erori de securitate
    \end{itemize}
    \item Ajută compilatorul
    \item Pot influența proiectarea limbajului
    \end{itemize}
    \vfill
    \begin{block}{Scop (ideal)}
    Progamele „bine formate“, i. e., cărora li se poate asocia un tip nu eșuează
    \end{block}
    \end{frame}

    \begin{frame}{Sisteme de tipuri --- Reguli intuitive}
      \begin{itemize}
        \item Variabilele trebuie declarate înainte de a fi folosite
        \item Variabilele nu își schimba tipul în timpul execuției
        \item operanzii asociați unui operator într-o expresie trebuie să
          se evalueze la valori corespunzătoare tipurilor așteptate de operator
        \item Condițiile din if și while se evaluează la valori Booleene
        \item Se fac operații I/O doar cu valori de tip întreg
      \end{itemize}
    \end{frame}

  \begin{frame}{Sisteme de tipuri}{Intuiție}
    \begin{itemize}
    \item Vom defini o relație \structure{$\Gamma \vdash frag : T$}
    \item Citim \structure{$frag$ are tipul $T$ dacă $\Gamma$}, unde
    \item $\Gamma$ — tipuri asociate variabilelor din $e$
    \end{itemize}

    \begin{block}{Exemple}
    \[\begin{array}{lll@{\;:\;}ll}
    &\vdash& \Sif {\Strue} \Sthen \{\} \Selse \{\} & \Sstmt
    \\\\
    x:\Sint&\vdash& x + 13 & \Sint
    \\\\
    x:\Sint&\not\vdash&x = y +1 &T&\mbox{pentru orice } T
    \end{array}\]
    \end{block}
    \end{frame}

    \begin{frame}{Tipuri în limbajul IMP}
    \begin{block}{Tipurile expresiilor = tipurile gramaticale}
    \[T ::= {\Sint} \mid {\Sbool} \mid \Sstmt\]
    \end{block}
    \begin{block}{$\Gamma$ --- Mediul de tipuri}
    \begin{itemize}
    \item Asociază tipuri variabilelor
    \(\Gamma : \mathbb{X} \xrightarrow{\circ}\mathbb{T}\)
    \item \structure{Notație:} o listă de perechi locație-tip
    \(x_1:t_1, \ldots, x_n:t_n\)
    \end{itemize}
  \end{block}
    \vfill
    \begin{block}{Observații pentru limbajul IMP}
    \begin{itemize}
    \item variabile din $\Gamma$  au tipul fie $\Sint$ fie $\Sbool$
    \item Apariția unei variabile în $\Gamma$ înseamnă că variabila a fost declarată
    \end{itemize}
    \end{block}
    \end{frame}

    \begin{frame}{IMP: Reguli formale pentru tipuri}
    \begin{block}{Tipul constantelor}
    \begin{itemize}
    \vitem[] $\reg[int]{\tjud{n}{\Sint}}{}{n \in \mathbb{Z}}$
    \vitem[] $\reg[bool]{\tjud{b}{\Sbool}}{}{b\in \{\Strue,\Sfalse\}}$
    \end{itemize}
    \end{block}
    \begin{block}{Tipul operatorilor}
        Operanzii asociați unui operator într-o expresie trebuie să
          se evalueze la valori corespunzătoare tipurilor așteptate de operator
    \begin{itemize}
    \vitem[] $\reg[op+]{\tjud{e_1 + e_2}{\Sint}}{\tjud{e_1}{\Sint} \si \tjud{e_2}{\Sint}}{}$
    \vitem[] $\reg[op$\leq$]{\tjud{e_1 \terminal{<=} e_2}{\Sbool}}{\tjud{e_1}{\Sint} \si \tjud{e_2}{\Sint}}{}$
    \vitem[] $\reg[op$!$]{\tjud{!e}{\Sbool}}{\tjud{e}{\Sbool}}{}$
    \end{itemize}
    \end{block}
  \end{frame}
  \begin{frame}{IMP: Reguli formale pentru tipuri}
    \begin{block}{Tipul variabilelor și al declarațiilor}
        \begin{itemize}
        \item Variabilele trebuie declarate înainte de a fi folosite
        \item Variabilele nu își schimba tipul în timpul execuției
      \vitem[] $\reg[loc]{\tjud{x}{t}}{}{\Gamma(x) = t}$
        \vitem[] $\reg[decl]{\tjud{\terminal{var} x = e ; sts}{stmt}}{\tjud{e}{t} \si \tjud[\Gamma, x \mapsto t]{sts}{stmt}}{}$
        \end{itemize}
    \end{block}
    \begin{block}{Instrucțiuni: Atribuire și secvențiere}
      \begin{itemize}
        \item Variabilele nu își schimba tipul în timpul execuției
    \vitem[] $\reg[atrib]{\tjud{x\terminal{=}e}{\Sstmt}}{\tjud{e}{t}}{\Gamma(x) = t}$
        \vitem[] $\reg[seq]{\tjud{st ; sts}{\Sstmt}}{\tjud{st}{\Sstmt} \si \tjud{sts}{stmt}}{st \textit{ nu e declaratie}}$
      \end{itemize}
    \end{block}
  \end{frame}
  \begin{frame}{IMP: Reguli formale pentru tipuri}
    \begin{block}{Tipuri pentru instrucțiuni}
        \begin{itemize}
        \item Condițiile din if și while se evaluează la valori Booleene
    \vitem[] $\reg[if]{\tjud{\Sif c \Sthen t \Selse e}{\Sstmt}}{\tjud{c}{\Sbool} \si \tjud{t}{{\Sstmt}} \si \tjud{e}{\Sstmt}}{}$
    \vitem[] $\reg[while]{\tjud{\Swhile (c)\,b}{\Sstmt}}{\tjud{c}{\Sbool} \si \tjud{b}{\Sstmt}}{}$
        \item Se fac operații I/O doar cu valori de tip întreg
    \vitem[] $\reg[read]{\tjud{\Sget (s, x)}{\Sstmt}}{}{\Gamma(x) = \Sint}$
    \vitem[] $\reg[print]{\tjud{\Sput (s, e)}{\Sstmt}}{\tjud{e}{\Sint}}{}$
    \end{itemize}
  \end{block}
    \end{frame}

\end{section}

\end{document}



